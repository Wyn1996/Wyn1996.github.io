<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>TCP/IP | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="TCP UDP    是否连接 面向连接 非连接   传输可靠性 可靠，不丢包 不可靠，丢包   数据顺序 保证顺序 不保证   数据模式 数据流 数据报   效率 效率低 效率高   资源占用 高 低   连接个数 点对点 一对多，多对多   首部开销 20字节 8字节   编程API 在connetct&#x2F;accept时确定地址信息 不需要listen和accept；收发数据使用send">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP">
<meta property="og:url" content="http://yoursite.com/2020/08/29/TCP-IP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="TCP UDP    是否连接 面向连接 非连接   传输可靠性 可靠，不丢包 不可靠，丢包   数据顺序 保证顺序 不保证   数据模式 数据流 数据报   效率 效率低 效率高   资源占用 高 低   连接个数 点对点 一对多，多对多   首部开销 20字节 8字节   编程API 在connetct&#x2F;accept时确定地址信息 不需要listen和accept；收发数据使用send">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/1Typora笔记/816045-20161105220355065-482198403.png">
<meta property="article:published_time" content="2020-08-29T02:05:31.000Z">
<meta property="article:modified_time" content="2020-08-29T02:06:26.064Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/1Typora笔记/816045-20161105220355065-482198403.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-TCP-IP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/29/TCP-IP/" class="article-date">
  <time datetime="2020-08-29T02:05:31.000Z" itemprop="datePublished">2020-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TCP/IP
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">面向连接</td>
<td align="center">非连接</td>
</tr>
<tr>
<td align="center">传输可靠性</td>
<td align="center">可靠，不丢包</td>
<td align="center">不可靠，丢包</td>
</tr>
<tr>
<td align="center">数据顺序</td>
<td align="center">保证顺序</td>
<td align="center">不保证</td>
</tr>
<tr>
<td align="center">数据模式</td>
<td align="center">数据流</td>
<td align="center">数据报</td>
</tr>
<tr>
<td align="center">效率</td>
<td align="center">效率低</td>
<td align="center">效率高</td>
</tr>
<tr>
<td align="center">资源占用</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">连接个数</td>
<td align="center">点对点</td>
<td align="center">一对多，多对多</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">20字节</td>
<td align="center">8字节</td>
</tr>
<tr>
<td align="center">编程API</td>
<td align="center">在connetct/accept时确定地址信息</td>
<td align="center">不需要listen和accept；收发数据使用sendto/recvfrom，并指定地址；shutdown无效</td>
</tr>
</tbody></table>
<p>相同点：传输层协议</p>
<p>2、TCP可靠传输原理</p>
<p>确认重传、流程控制、拥塞控制和数据校验</p>
<p>3、OSI七层模型：</p>
<ul>
<li><p>物理层</p>
</li>
<li><p>数据链路层</p>
</li>
<li><p>网络层：ICMP IGMP IP</p>
</li>
<li><p>传输层：TCP UDP</p>
</li>
<li><p>会话层</p>
</li>
<li><p>表示层：JPEG ASCII EBCDIC </p>
</li>
<li><p>应用层：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p>
</li>
</ul>
<p>4、TCP三次握手四次挥手</p>
<p><img src="D:\1Typora笔记\816045-20161105220355065-482198403.png" alt="816045-20161105220355065-482198403"></p>
<ul>
<li><strong>CLOSED</strong>：初始状态</li>
</ul>
<ul>
<li><p><strong>LISTEN（服务器）</strong>：监听端口</p>
</li>
<li><p><strong>SYN_RECD（服务器）</strong>：接收到SYN报文，多数情况下此状态很短暂，除非故意不发送ACK给客户端</p>
</li>
<li><p><strong>SYN_SENT（客户端）</strong>：客户端执行connect后发送SYN给服务器后进入该状态</p>
</li>
<li><p><strong>ESTABLISHED</strong>：连接已建立</p>
</li>
<li><p><strong>FIN_WAIT_1</strong>：其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 </p>
</li>
<li><p><strong>FIN_WAIT_2</strong>： 实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接 </p>
</li>
<li><p><strong>TIME_WAIT</strong>：表示收到了对方的FIN报文，并发送了ACK报文，就等2MSL后即可回到CLOSED状态。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p>
<p><strong>注:MSL(最大分段生存期)指明TCP报文在Internet上最长生存时间,每个具体的TCP实现都必须选择一个确定的MSL值.RFC 1122建议是2分钟,但BSD传统实现采用了30秒.TIME_WAIT 状态最大保持时间是2 * MSL,也就是1-4分钟.</strong></p>
<p>　　<strong>结论：在TIME_WAIT下等待2MSL，只是为了尽最大努力保证四次握手正常关闭。确保老的报文段在网络中消失，不会影响新建立的连接.</strong></p>
</li>
<li><p><strong>CLOSING</strong>： 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 </p>
</li>
<li><p><strong>CLOSE_WAIT</strong>： 当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 </p>
</li>
<li><p><strong>LAST_ACK</strong>： 它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。 </p>
</li>
</ul>
<p><em>补充</em>：</p>
<p>a、默认情况下，当调用close时，如果缓冲区中还有数据，会先将数据发送完</p>
<p>b、发送了FIN只是表示这端不能继续发送数据（应用层不等在调用send发送），但是还可以接受数据</p>
<p>c、应用层如何知道对端关闭？通常在最简单的阻塞模型中，当调用recv时，如果返回0，则表示对端关闭。在这个时候通常做法是也调用close，通过TCP发送FIN完成挥手。</p>
<p>d、很多时候，TCP连接的断开都会由TCP层自动进行，例如通过CTRL+C终止程序，TCP连接依然会正常关闭。</p>
<p><em>思考</em>：</p>
<p> <strong>1、 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？*<br>*</strong>　　这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 </p>
<p> <strong>2. 为什么不能用两次握手进行连接？*<br>*</strong>　　我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>　　现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在  S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的数据分组超时后，重复发送同样的数据分组。这样就形成了死锁。 </p>
<p><strong>3. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？*<br>*</strong>　　什么是2MSL？MSL即Maximum Segment Lifetime，也就是报文最大生存时间，引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间。”那么，2MSL也就是这个时间的2倍，当TCP连接完成四个报文段的交换时，主动关闭的一方将继续等待一定时间(2-4分钟)，即使两端的应用程序结束。例如在客户端关闭后，使用netstat查看的结果:<br>C:&gt;netstat -na | find “172.29.21.25”<br>TCP 172.29.132.60:2795 172.29.21.25:23 TIME_WAIT</p>
<p> <strong>为什么需要这个2MSL呢？</strong><br>　　第一，虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。<br>　　第二，报文可能会被混淆，意思是说，其他时候的连接可能会被当作本次的连接。直接引用《The TCP/IP Guide》的说法：The second is to provide a “buffering period” between the end of this connection and any subsequent ones. If not for this period, it is possible that packets from different connections could be mixed, creating confusion.</p>
<p>　　当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个TCP连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然crash掉了，那么它将无法在2MSL内重新启动，因为bind会失败。解决这个问题的一个方法就是设置socket的SO_REUSEADDR选项。这个选项意味着你可以重用一个地址。</p>
<p>　　当建立一个TCP连接时，服务器端会继续用原有端口监听，同时用这个端口与客户端通信。而客户端默认情况下会使用一个随机端口与服务器端的监听端口通信。有时候，为了服务器端的安全性，我们需要对客户端进行验证，即限定某个IP某个特定端口的客户端。客户端可以使用bind来使用特定的端口。对于服务器端，当设置了SO_REUSEADDR选项时，它可以在2MSL内启动并listen成功。但是对于客户端，当使用bind并设置SO_REUSEADDR时，如果在2MSL内启动，虽然bind会成功，但是在windows平台上connect会失败。而在<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/linux">Linux</a>上则不存在这个问题。(我的实验平台：winxp, ubuntu7.10)</p>
<p>　　要解决windows平台的这个问题，可以设置SO_LINGER选项。SO_LINGER选项决定调用close时TCP的行为。SO_LINGER涉及到linger结构体，如果设置结构体中l_onoff为非0，l_linger为0，那么调用close时TCP连接会立刻断开，TCP不会将发送缓冲中未发送的数据发送，而是立即发送一个RST报文给对方，这个时候TCP连接(关闭时)就不会进入TIME_WAIT状态。如你所见，这样做虽然解决了问题，但是并不安全。通过以上方式设置SO_LINGER状态，等同于设置SO_DONTLINGER状态。</p>
<p>　　当TCP连接发生一些物理上的意外情况时，例如网线断开，linux上的TCP实现会依然认为该连接有效，而windows则会在一定时间后返回错误信息。这似乎可以通过设置SO_KEEPALIVE选项来解决，不过不知道这个选项是否对于所有平台都有效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/29/TCP-IP/" data-id="ckef11btk0001y8vra8fweg55" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/08/29/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/29/TCP-IP/">TCP/IP</a>
          </li>
        
          <li>
            <a href="/2020/08/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>